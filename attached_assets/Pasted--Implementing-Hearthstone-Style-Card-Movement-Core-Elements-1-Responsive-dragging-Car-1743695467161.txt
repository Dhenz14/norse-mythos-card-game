# Implementing Hearthstone-Style Card Movement

## Core Elements
1. **Responsive dragging** - Cards follow cursor with no lag
2. **Smooth animations** - Cards snap to valid positions or return to hand
3. **Visual effects** - Scale/rotate cards while dragging

## Implementation

### HTML/CSS Setup
```html
<div class="hand">
  <div class="card" id="card-1">Card 1</div>
  <!-- more cards... -->
</div>
<div class="board">
  <!-- board slots -->
</div>
```

```css
.card {
  position: absolute;
  cursor: grab;
  transition: transform 0.2s ease;
}
.card:active {
  cursor: grabbing;
}
```

### JavaScript Logic

#### 1. Drag Initialization
```js
const cards = document.querySelectorAll('.card');
let offsetX = 0, offsetY = 0;
let isDragging = false;
let draggedCard = null;

cards.forEach(card => {
  card.addEventListener('pointerdown', (e) => {
    isDragging = true;
    draggedCard = e.target;
    draggedCard.style.zIndex = 9999;
    
    // Calculate offset from grab point
    offsetX = e.clientX - draggedCard.getBoundingClientRect().left;
    offsetY = e.clientY - draggedCard.getBoundingClientRect().top;
    
    // Scale up card
    draggedCard.style.transform = `scale(1.1)`;
  });
});
```

#### 2. Card Movement
```js
document.addEventListener('pointermove', (e) => {
  if (isDragging && draggedCard) {
    const x = e.clientX - offsetX;
    const y = e.clientY - offsetY;
    
    // Add slight rotation based on cursor position
    const rotationFactor = 0.05;
    const rotation = (e.clientX - offsetX) * rotationFactor;
    
    draggedCard.style.transform = 
      `translate(${x}px, ${y}px) scale(1.1) rotate(${rotation}deg)`;
  }
});
```

#### 3. Card Release & Snapping
```js
document.addEventListener('pointerup', () => {
  if (isDragging && draggedCard) {
    snapOrRevert(draggedCard);
    isDragging = false;
    draggedCard = null;
  }
});

function snapOrRevert(card) {
  const board = document.querySelector('.board');
  const cardRect = card.getBoundingClientRect();
  const boardRect = board.getBoundingClientRect();
  
  // Check if card is over valid drop zone
  if (isOverValidDropZone(cardRect, boardRect)) {
    // Snap to board slot
    const targetPosition = getTargetBoardPosition(card);
    animateCardTo(card, targetPosition.x, targetPosition.y);
  } else {
    // Return to hand
    const originalPosition = getOriginalHandPosition(card);
    animateCardTo(card, originalPosition.x, originalPosition.y);
  }
}
```

#### 4. Animation Function (using GSAP)
```js
function animateCardTo(card, x, y) {
  gsap.to(card, {
    x: x,
    y: y,
    scale: 1,
    rotation: 0,
    duration: 0.3,
    ease: "power2.out"
  });
}
```

#### 5. Alternative: Pure JS Animation
```js
function animateCardTo(card, startX, startY, endX, endY, duration = 300) {
  const startTime = performance.now();
  
  function animate(time) {
    const elapsed = time - startTime;
    const progress = Math.min(elapsed / duration, 1);
    const ease = 1 - Math.pow(1 - progress, 3); // Cubic ease-out
    
    const currentX = startX + (endX - startX) * ease;
    const currentY = startY + (endY - startY) * ease;
    
    card.style.transform = `translate(${currentX}px, ${currentY}px) scale(${1 + 0.1 * (1-ease)})`;
    
    if (progress < 1) {
      requestAnimationFrame(animate);
    }
  }
  
  requestAnimationFrame(animate);
}
```

## Performance Tips
- Use `transform` instead of `top/left` for smoother animations
- Handle touches correctly for mobile with `pointer` events
- Limit DOM operations during animations

## Polish Features
- Add glowing outlines to valid drop zones
- Scale cards slightly when hovering over them
- Add subtle audio feedback
- Use slight shadow/elevation when card is lifted