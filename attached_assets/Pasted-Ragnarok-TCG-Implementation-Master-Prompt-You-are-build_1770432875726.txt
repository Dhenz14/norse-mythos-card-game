Ragnarok – TCG Implementation Master Prompt

You are building Ragnarok, a digital Trading Card Game (TCG) inspired by mythological warfare, strategic depth, and competitive mastery. This is not an MMO. It is a turn-based, card-driven strategy game with long-term live service goals, competitive balance, and extensibility.

Your objective is to design and implement Ragnarok at AAA-quality standards, with systems that are cleanly architected, modular, testable, and built to evolve over many years of updates, expansions, and balance passes.

This is not about making something that merely works — it is about building a TCG platform that remains understandable, adaptable, and maintainable five years from now.

Core Architectural Philosophy
Separation of Concerns

Every system must have a single responsibility and operate independently:

Game rules & card logic must be completely decoupled from:

UI / animations

Networking or multiplayer synchronization

Persistence (NFTs, player collections, match history)

Card resolution, damage calculation, resource handling, and effect timing must be pure, deterministic logic that can be tested in isolation.

A balance change should never require touching UI code.
A new card effect should not require rewriting core systems.

Clear Interfaces & Contracts

Each major system must expose a well-defined API:

Card resolution engine

Turn/state machine

Resource system (HP, mana, stamina, rage, etc.)

Deck construction & validation

Match lifecycle management

Internal implementations must remain hidden behind these interfaces so systems can be rewritten, optimized, or replaced without breaking dependent code.

Single Source of Truth

All game state must have one authoritative owner:

A card’s stats, buffs, and status effects exist in one place

Player resources are not duplicated across systems

Match state flows in one direction through a state machine

No mirrored state. No desynchronization risks. No ambiguity.

Code Quality Standards

Code must be self-explanatory through naming and structure

Function and variable names should clearly express intent
(e.g., resolveAttackPhase() instead of handleStuff())

Single-Responsibility Functions

Each function does one thing only:

No function should calculate damage and apply effects and update UI and log results

Break logic into small, composable units that behave like LEGO blocks

Consistency Is Mandatory

Establish and follow consistent patterns for:

Turn resolution

Effect stacking and timing

Error handling

Validation

Logging

There should never be multiple “styles” of doing the same thing.

Documentation as a First-Class Requirement

Documentation is part of the system, not an afterthought.

For every major system:

Explain what problem it solves

Explain why this approach was chosen

Document alternatives that were rejected and why

Living Documentation

Documentation must be updated every time code behavior changes.
Outdated documentation is worse than none.

API & System Diagrams

Provide usage examples for all public interfaces

Document common pitfalls and edge cases

Maintain diagrams showing:

Turn flow

Card resolution order

Data ownership and state transitions

Code Lifecycle & Technical Debt Prevention

Refactor continuously — never “later”

Remove dead code completely (version control preserves history)

Never leave deprecated systems commented out or dormant

Automated Quality Enforcement

Use:

Linting

Static analysis

Complexity limits

CI checks that reject low-quality code

Quality degradation should be caught before merge, not after release.

Innovation & Custom Implementation Rules

Before building anything:

Understand the problem deeply

Study proven TCG patterns and systems

Identify Ragnarok-specific constraints

Use existing libraries only if they align with long-term architecture.
Reject tools that impose incompatible design philosophies.

Custom Systems

Only build custom solutions when:

Existing ones cannot meet requirements

The tradeoffs are clearly justified and documented

All custom systems must be:

Modular

Replaceable

Loosely coupled

Performance as a Continuous Discipline

Even for a TCG:

Measure performance from day one

Instrument card resolution, turn processing, and state transitions

Track memory usage and execution time

Optimize Based on Data

Never optimize blindly

Profile first

Prefer algorithmic improvements over micro-optimizations

Testing as Both QA and Documentation

Unit tests for card logic and effects

Integration tests for turn flow and state transitions

Performance tests for large-scale card interactions

Tests are executable documentation and must never be ignored.

Failing tests are non-negotiable — fix or update immediately.

Collaboration & Knowledge Sharing

Maintain clear onboarding documentation

Explain not just how systems work, but why

Use code reviews as teaching moments, not gatekeeping

When better patterns emerge:

Update standards

Refactor existing code

Prevent “old style vs new style” fragmentation

The Goal

You are not building a simple card game.
You are building a competitive, expandable, mythological TCG platform that can support:

Years of balance updates

New card sets and pantheons

Competitive play and tournaments

NFT-backed ownership and progression

High standards are not constraints — they are what make sustained excellence possible.

Build systems that are:

Elegant

Testable

Replaceable

Scalable

Battle-tested

This is the foundation of Ragnarok.