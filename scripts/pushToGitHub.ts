/**
 * Push changes to GitHub using Octokit
 * Run with: npx tsx scripts/pushToGitHub.ts "commit message"
 * 
 * Uses Replit's GitHub connector for authentication
 * 
 * SECURITY: This script validates files against forbidden patterns
 * before pushing. See docs/GITHUB_SECURITY_GUIDE.md for details.
 */

import { Octokit } from '@octokit/rest';
import * as fs from 'fs';
import * as path from 'path';

// ============================================
// SECURITY: Files that should NEVER be pushed
// ============================================
const FORBIDDEN_FILES = [
  '.replit',
  'replit.nix',
  '.replit-rules.json',
  'replit.md',
  'replit_push_status.json',
  'log_mapping.json',
  'nohup.out',
  '.env',
  '.env.local',
  '.env.production',
];

const FORBIDDEN_PATTERNS = [
  /\.db$/,
  /\.sqlite$/,
  /\.pem$/,
  /\.key$/,
  /\.secret$/,
  /_credentials\.json$/,
  /^\.env\./,
];

const FORBIDDEN_CONTENT_PATTERNS = [
  /DATABASE_URL\s*[:=]\s*["'][^"']+["']/,
  /API_KEY\s*[:=]\s*["'][^"']+["']/,
  /SECRET_KEY\s*[:=]\s*["'][^"']+["']/,
  /postgresql:\/\/[^"'\s]+/,
  /REPLIT_DB_URL/,
];

function isForbiddenFile(filePath: string): { forbidden: boolean; reason?: string } {
  const fileName = path.basename(filePath);
  
  // Check exact matches
  if (FORBIDDEN_FILES.includes(fileName)) {
    return { forbidden: true, reason: `'${fileName}' is a Replit internal file` };
  }
  
  // Check patterns
  for (const pattern of FORBIDDEN_PATTERNS) {
    if (pattern.test(filePath)) {
      return { forbidden: true, reason: `'${filePath}' matches forbidden pattern ${pattern}` };
    }
  }
  
  return { forbidden: false };
}

function checkContentForSecrets(content: string, filePath: string): { safe: boolean; warnings: string[] } {
  const warnings: string[] = [];
  
  for (const pattern of FORBIDDEN_CONTENT_PATTERNS) {
    if (pattern.test(content)) {
      warnings.push(`'${filePath}' may contain sensitive data matching ${pattern}`);
    }
  }
  
  return { safe: warnings.length === 0, warnings };
}

let connectionSettings: any;

async function getAccessToken() {
  if (connectionSettings && connectionSettings.settings.expires_at && new Date(connectionSettings.settings.expires_at).getTime() > Date.now()) {
    return connectionSettings.settings.access_token;
  }
  
  const hostname = process.env.REPLIT_CONNECTORS_HOSTNAME;
  const xReplitToken = process.env.REPL_IDENTITY 
    ? 'repl ' + process.env.REPL_IDENTITY 
    : process.env.WEB_REPL_RENEWAL 
    ? 'depl ' + process.env.WEB_REPL_RENEWAL 
    : null;

  if (!xReplitToken) {
    throw new Error('X_REPLIT_TOKEN not found for repl/depl');
  }

  connectionSettings = await fetch(
    'https://' + hostname + '/api/v2/connection?include_secrets=true&connector_names=github',
    {
      headers: {
        'Accept': 'application/json',
        'X_REPLIT_TOKEN': xReplitToken
      }
    }
  ).then(res => res.json()).then(data => data.items?.[0]);

  const accessToken = connectionSettings?.settings?.access_token || connectionSettings.settings?.oauth?.credentials?.access_token;

  if (!connectionSettings || !accessToken) {
    throw new Error('GitHub not connected');
  }
  return accessToken;
}

async function getGitHubClient() {
  const accessToken = await getAccessToken();
  return new Octokit({ auth: accessToken });
}

async function pushFiles() {
  const owner = 'Dhenz14';
  const repo = 'norse-mythos-card-game';
  const branch = 'main';
  const commitMessage = process.argv[2] || 'Update from Replit';

  console.log('üöÄ Pushing to GitHub...');
  console.log(`   Repository: ${owner}/${repo}`);
  console.log(`   Branch: ${branch}`);
  console.log(`   Message: ${commitMessage}`);
  console.log('');
  console.log('üîí Security check enabled');

  try {
    const octokit = await getGitHubClient();

    const { data: refData } = await octokit.git.getRef({
      owner,
      repo,
      ref: `heads/${branch}`,
    });
    const currentCommitSha = refData.object.sha;

    const { data: commitData } = await octokit.git.getCommit({
      owner,
      repo,
      commit_sha: currentCommitSha,
    });
    const treeSha = commitData.tree.sha;

    // Files to push - SECURITY: Never include Replit internal files
    const filesToPush = [
      'docs/DESIGN_PHILOSOPHY.md',
      'docs/DECK_BUILDER_AUDIT.md',
      'docs/GITHUB_SECURITY_GUIDE.md',
      'scripts/pushToGitHub.ts',
      'scripts/cleanupGitHub.ts',
      '.gitignore',
    ];

    const treeItems: any[] = [];
    const securityWarnings: string[] = [];

    for (const filePath of filesToPush) {
      // Security check: forbidden file
      const forbiddenCheck = isForbiddenFile(filePath);
      if (forbiddenCheck.forbidden) {
        console.log(`   ‚õî BLOCKED: ${forbiddenCheck.reason}`);
        continue;
      }

      const fullPath = path.join(process.cwd(), filePath);
      if (fs.existsSync(fullPath)) {
        const content = fs.readFileSync(fullPath, 'utf-8');
        
        // Security check: content patterns
        const contentCheck = checkContentForSecrets(content, filePath);
        if (!contentCheck.safe) {
          securityWarnings.push(...contentCheck.warnings);
          console.log(`   ‚ö†Ô∏è  WARNING: ${filePath} may contain sensitive data`);
        }

        const { data: blob } = await octokit.git.createBlob({
          owner,
          repo,
          content,
          encoding: 'utf-8',
        });
        treeItems.push({
          path: filePath,
          mode: '100644',
          type: 'blob',
          sha: blob.sha,
        });
        console.log(`   ‚úì Added: ${filePath}`);
      }
    }

    if (securityWarnings.length > 0) {
      console.log('');
      console.log('‚ö†Ô∏è  Security warnings detected:');
      securityWarnings.forEach(w => console.log(`   - ${w}`));
      console.log('   Review files before proceeding.');
    }

    if (treeItems.length === 0) {
      console.log('No files to push.');
      return;
    }

    const { data: newTree } = await octokit.git.createTree({
      owner,
      repo,
      base_tree: treeSha,
      tree: treeItems,
    });

    const { data: newCommit } = await octokit.git.createCommit({
      owner,
      repo,
      message: commitMessage,
      tree: newTree.sha,
      parents: [currentCommitSha],
    });

    await octokit.git.updateRef({
      owner,
      repo,
      ref: `heads/${branch}`,
      sha: newCommit.sha,
    });

    console.log('');
    console.log('‚úÖ Successfully pushed to GitHub!');
    console.log(`   Commit: ${newCommit.sha.substring(0, 7)}`);
    console.log(`   URL: https://github.com/${owner}/${repo}/commit/${newCommit.sha}`);

  } catch (error: any) {
    console.error('‚ùå Error pushing to GitHub:', error.message);
    process.exit(1);
  }
}

pushFiles();
